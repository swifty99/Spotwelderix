substitutions:
  plug_name: "spottest"
  ADCa_CHANNEL_CURR:  "5"
  ADC_CHANNEL_PROBE_PLUS: "6"
  ADC_CHANNEL_PROBE_NEG:  "7"
  # these are the channels on direct HW access. see ESP32 data sheet.
  # this SW does not use HAL for ADC and Gate IO. These add intolerable delays.
  
esphome:
  name: ${plug_name}
  project:
    name: "kipping.spotwelderix"
    version: "0.1.0"
  platform: ESP32
  board: nodemcu-32s  
  on_boot:
    priority: 700 #switches available
    then:
      #- rtttl.play:
      #    rtttl: "two short:d=4,o=5,b=100:16e6,16e6"
      - switch.turn_on: power_on 
      - delay: 0.1sec    
      #- switch.turn_off: disp_reset
      

      #- rtttl.play:
      #    rtttl: "two short:d=4,o=5,b=100:16e6,16e6"
      - number.set:
          id: energy_target
          value: 42

      # remove display dirt, bad workaround, shoulb be better
      - delay: 0.2sec    
      #- switch.turn_on: disp_reset
      
      - delay: 20sec    
      - lambda:  id(my_preweld_time_usec) = id(my_preweld_time_usec_number).state;  
      - lambda: id(my_preweldpause_time_usec) = id(my_preweldpause_time_usec_number).state;
      - component.update: my_display 
      - delay: 100ms
      - component.update: my_display 
      - delay: 100ms
      - component.update: my_display 
      - delay: 100ms
      - component.update: my_display 
      - delay: 100ms

  includes:
    - my_welder.h


wifi:
  networks:
  - ssid: BitPups
    password: Schnittlauch
  - ssid: "Bit4Me"
    password: !secret wifi_pw_home 
  
  manual_ip:
    # Set this to the IP of the ESP
    static_ip: 192.168.42.86
    # Set this to the IP address of the router. Often ends with .1
    gateway: 192.168.42.1
    # The subnet of the network. 255.255.255.0 works for most home networks.
    subnet: 255.255.255.0  

  # Enable fallback hotspot (captive portal) in case wifi connection fails
  ap:
    ssid: "${plug_name} Fallback Hotspot"
    password: "Schnittlauch"

captive_portal:



logger:
  level: DEBUG
  logs:
    adc: ERROR
    sensor: INFO

api:
  reboot_timeout : 0s

ota:


web_server:
  port: 80

time:
  - platform: homeassistant
  #- platform: sntp
    id: sntp_time
    # servers:
    #   - 0.de.pool.ntp.org
    #   - 3.de.pool.ntp.org

dallas:
  - pin: 13

spi:
  clk_pin: 17
  mosi_pin: 16
  miso_pin: 15


globals:
  - id: my_global_energy_target
    type: unsigned int
    restore_value: no
    initial_value: '31'

    # Weld.h stuff:
    
  - id: my_weld_time
    type: unsigned int
    restore_value: no
    initial_value: '42'

  - id: my_preweld_time_usec
    type: unsigned int
    restore_value: no
    initial_value: '1000'

  - id: my_preweldpause_time_usec
    type: unsigned int
    restore_value: no
    initial_value: '800'

  - id: my_weld_max_p
    type: unsigned int
    restore_value: no
    initial_value: '1234'

    
  - id: my_weld_voltref_adj_1v
    type: int
    restore_value: yes   

  - id: my_weld_voltref_adj_10v
    type: int
    restore_value: yes

  - id: my_weld_currref_adj_1a
    type: int
    restore_value: yes   

  - id: my_weld_currref_adj_10a
    type: int
    restore_value: yes

  - id: my_weld_count
    type: unsigned int
    restore_value: no
    initial_value: '0'

  - id: my_weld_energy
    type: unsigned int
    restore_value: no
    initial_value: '123'

  - id: my_weld_energy_target_intern
    type: float
    restore_value: no
    initial_value: '1'

  - id: my_weld_request
    type: unsigned int
    restore_value: no
    initial_value: '0'


  - id: my_global_weld_powerflow
    type: int[30]
    restore_value: no


  # UI vars

number:


        
  - platform: template
    id:  energy_target
    min_value: 0.1
    max_value: 20
    step: 0.1
    optimistic: true
    name: "Energy Target"
    on_value:
      then:
        #copy number to global to access it in my_welder.h
        lambda:  id(my_weld_energy_target_intern) = id(energy_target).state;

        
  - platform: template
    id:  my_preweld_time_usec_number
    min_value: 0
    max_value: 25000
    step: 250
    optimistic: true
    
    restore_value: yes   
    name: "µsec preweld time"
    on_value:
      then:
        #copy number to global to access it in my_welder.h
        lambda:  id(my_preweld_time_usec) = id(my_preweld_time_usec_number).state;



  - platform: template
    id:  my_preweldpause_time_usec_number
    min_value: 0
    max_value: 25000
    step: 250
    optimistic: true
    
    restore_value: yes   
    name: "µsec preweld pause time"
    on_value:
      then:
        - logger.log: "hi"
        #copy number to global to access it in my_welder.h
        - lambda:  !lambda |-
            id(my_preweldpause_time_usec) = id(my_preweldpause_time_usec_number).state;
            ESP_LOGI("custom", "Value of my number: %f", (float) id(my_preweldpause_time_usec_number).state );



  - platform: template
    id:  my_ui_update_rq
    min_value: 0
    max_value: 1
    step: 1
    optimistic: true
    name: "Update UI Now"   
    on_value_range:
      above: 0
      then:
        - component.update: my_display 
        - number.set:
            id: my_ui_update_rq
            value: 0
        - logger.log: update rq reset

        




sensor:




# Extra sensor to keep track of plug uptime
  - platform: uptime
    name: '${plug_name}_Uptime'
    unit_of_measurement: Tage
    update_interval: 300s
    filters:
      - multiply: 0.000011574
      
  - platform: wifi_signal
    name: "${plug_name}_WiFi_Signal"
    update_interval: 60s


  - platform: dallas
    address: 0x880315A4D71EFF28
    name: "PCB Temperature"
    id: mytempsens

  - platform: rotary_encoder
    name: "Rotary Encoder"
    resolution: 2
    pin_a: 36
    pin_b: 39



  - platform: adc
    pin: 32
    id: supply_volt
    name: "Supply Voltage"
    attenuation: 11db
    update_interval: 510ms
    filters:
      # convert back to raw, do const adjust and number adjust. do same in weld.h
      - lambda: return x  ;
      # * id(my_weld_voltref_adj); 
      - sliding_window_moving_average:
          window_size: 4
          send_every: 2



  - platform: adc
    pin: 35
    id: probe_minus
    name: "Probe ground volt"
    attenuation: 11db
    update_interval: 200ms
    filters:
      - multiply: 7.8
      - sliding_window_moving_average:
          window_size: 3
          send_every: 2

# configured only to set attenuation
  - platform: adc
    pin: 34
    id: battadc
    attenuation: 11db
  - platform: adc
    pin: 33
    id: curradc
    attenuation: 11db

  


  - platform: template
    id: batt_volt
    name: "Battery Voltage"
    lambda: |-
      float raw_adc_avg = (float) ( adc1_get_raw((adc1_channel_t)  ${ADC_CHANNEL_PROBE_PLUS} ) 
      + adc1_get_raw((adc1_channel_t)  ${ADC_CHANNEL_PROBE_PLUS} ) 
      + adc1_get_raw((adc1_channel_t)  ${ADC_CHANNEL_PROBE_PLUS} ) )/3;
      
      float p1 = 1;
      float p2 = 10;
      if (id(my_weld_voltref_adj_10v) - id(my_weld_voltref_adj_1v) == 0){
        ESP_LOGE("custom", "Invalid calibration of Battery Voltage" );
        return 0;
      }
      float slope = (p2 - p1) / (id(my_weld_voltref_adj_10v) - id(my_weld_voltref_adj_1v))  ;
      float offset = p1- id(my_weld_voltref_adj_1v) * slope;
      //ESP_LOGI("custom", "slope U: %f , offset: %f",  slope, offset );

      return raw_adc_avg * slope + offset;
      
    update_interval: 2s

  - platform: template
    id: current
    name: "current"
    lambda: |-

      float raw_adc_avg = (float) ( adc1_get_raw((adc1_channel_t)  ${ADCa_CHANNEL_CURR} ) 
      + adc1_get_raw((adc1_channel_t)  ${ADCa_CHANNEL_CURR} ) 
      + adc1_get_raw((adc1_channel_t)  ${ADCa_CHANNEL_CURR} ) )/3;
      
      float p1 = 0;
      float p2 = 10;
      if (id(my_weld_currref_adj_10a)  == 0){
        ESP_LOGE("custom", "Invalid calibration of Battery Current" );
        return 0;}
      
      float slope = (p2 - p1) / (id(my_weld_currref_adj_10a) )  ;
      float offset = 0 * slope;
      //ESP_LOGI("custom", "slope I: %f , offset: %f",  slope, offset );

      return raw_adc_avg * slope + offset;
      
    update_interval: 2s





binary_sensor:

  - platform: custom
    lambda: |-
      auto my_welder = new MyWelder();
      App.register_component(my_welder);
      return {my_welder};

    binary_sensors:
      name: "My Custom Weld Function"
      id: my_custom_welder_ui_req
      on_state:
        then:
          if: 
            condition:
              lambda: 'return id(my_custom_welder_ui_req).state > 0;'
            then:
              - component.update: my_display 
              - logger.log: "update rq reset"

  - platform: gpio
    id: pullup__
    pin:
      number: 13
      mode: INPUT_PULLUP
    filters:
      - delayed_on: 100ms

  - platform: gpio
    id: foot_switch
    name: "Foot switch"
    pin:
      number: 4
      mode: INPUT_PULLUP
      inverted: true
    filters:
      - delayed_on: 100ms   
    on_press:
      then:
        lambda: id(my_weld_request) = 1;

  # - platform: gpio
  #   id: pullup2__
  #   pin:
  #     number: 19
  #     mode: INPUT_PULLUP
  #   filters:
  #     - delayed_on: 100ms

  - platform: gpio
    id: user_switch
    name: "User Push"
    pin:
      number: 23
      inverted: true
      mode: INPUT_PULLUP
          
    filters:
      - delayed_on: 100ms



switch:

  # Calibration "buttons to adjust ADC values"
  - platform: template
    name: "Spannung auf 1V gesetzt"
    id: calibrate_volt_1v
    optimistic: true
    turn_on_action:
      - lambda: |-
          id(my_weld_voltref_adj_1v) = ( adc1_get_raw((adc1_channel_t)   ${ADC_CHANNEL_PROBE_PLUS} ) 
          + adc1_get_raw((adc1_channel_t)   ${ADC_CHANNEL_PROBE_PLUS} ) 
          +adc1_get_raw((adc1_channel_t)   ${ADC_CHANNEL_PROBE_PLUS} ) )/3;
          ESP_LOGI("custom", "Raw ADC voltage 1V set to: %d",  id(my_weld_voltref_adj_1v) );

      - switch.turn_off: calibrate_volt_1v
      - switch.template.publish:
          id: calibrate_volt_1v
          state: OFF      

  - platform: template
    name: "Spannung auf 10V gesetzt"
    id: calibrate_volt_10v
    optimistic: true
    turn_on_action:
      - lambda: |-
          id(my_weld_voltref_adj_10v) = ( adc1_get_raw((adc1_channel_t)   ${ADC_CHANNEL_PROBE_PLUS} ) 
          + adc1_get_raw((adc1_channel_t)   ${ADC_CHANNEL_PROBE_PLUS} ) 
          +adc1_get_raw((adc1_channel_t)   ${ADC_CHANNEL_PROBE_PLUS} ) )/3;
          ESP_LOGW("custom", "Raw ADC voltage 10V set to: %d",  id(my_weld_voltref_adj_10v) );

      - switch.turn_off: calibrate_volt_10v
      - switch.template.publish:
          id: calibrate_volt_10v
          state: OFF




  - platform: template
    name: "Current set to 10A"
    id: calibrate_amps_10a
    optimistic: true
    turn_on_action:
      - lambda: |-
          // reconfigure ADC to get more accurate 10A reading
          adc1_config_channel_atten((adc1_channel_t) ${ADCa_CHANNEL_CURR}, (adc_atten_t) 0);
          id(my_weld_currref_adj_10a) = ( adc1_get_raw((adc1_channel_t)   ${ADCa_CHANNEL_CURR} ) 
          + adc1_get_raw((adc1_channel_t)   ${ADCa_CHANNEL_CURR} ) 
          +adc1_get_raw((adc1_channel_t)   ${ADCa_CHANNEL_CURR} ) )/3/3.55;  // compensate lower attenuation
          adc1_config_channel_atten((adc1_channel_t) ${ADCa_CHANNEL_CURR}, (adc_atten_t) 3);
          ESP_LOGW("custom", "Raw ADC current 10A set to: %d",  id(my_weld_currref_adj_10a) );

      - delay: 1s
      - switch.turn_off: calibrate_amps_10a
      - switch.template.publish:
          id: calibrate_amps_10a
          state: OFF







  # - platform: gpio
  #   pin: 19
  #   #inverted: True
  #   id: reset_dos
  #   name: "rest disp"  


  - platform: gpio
    pin: 22
    #inverted: True
    id: power_on
    name: "Power"  


  - platform: gpio
    pin: 27
    #inverted: True
    id: weld
    name: "Weld it!"  
      

output:
  - platform: ledc
    pin: GPIO26
    id: rtttl_out


rtttl:
  output: rtttl_out



  
font:
  - file: 'fonts/DosisSB.ttf'
    id: dosis_sb_48
    size: 48
  - file: 'fonts/DosisSB.ttf'
    id: dosis_sb_20
    size: 20
  - file: 'fonts/DosisSB.ttf'
    id: dosis_sb_96
    size: 92
  - file: 'fonts/DosisSB.ttf'
    id: dosis_sb_72
    size: 72

display:
  - platform: waveshare_epaper
    id: my_display
    cs_pin: 5
    dc_pin: 18
    busy_pin: 21
    reset_pin: 19
    model: 1.54inv2
    full_update_every: 5
    rotation: 90
    update_interval: 30 sec
    lambda: |-
      // api disc https://esphome.io/api/display__buffer_8h.html
      // Topr Row_ Peek P and time  my_weld_time
      it.printf(0, -4, id(dosis_sb_20),  "Peak: %dW",   id(my_weld_max_p));
      it.printf(it.get_width(), -4, id(dosis_sb_20), TextAlign::TOP_RIGHT , "%d ms",   id(my_weld_time));

      // show energy and target
      it.printf(it.get_width()/2 +40, it.get_height()/2 +48, id(dosis_sb_48), TextAlign::BOTTOM_RIGHT , "%d",  id(my_weld_energy) );
      it.printf(it.get_width()/2 + 48, it.get_height()/2 +48 -10, id(dosis_sb_20), TextAlign::BOTTOM_LEFT , "J");
      
      it.printf(it.get_width()/2 +20, it.get_height()/2 +40, id(dosis_sb_20), TextAlign::CENTER_HORIZONTAL  , "Target E: %.1f J",   id(energy_target).state);

      // draw the power curve
      
      // bottom row Temp / Batt_
      it.printf(0, it.get_height() - 20, id(dosis_sb_20),  "%.1f°C  %.1f V",  id(mytempsens).state,   id(batt_volt).state);
      it.printf(it.get_width(), it.get_height() - 20, id(dosis_sb_20), TextAlign::RIGHT , "weld %d",   id(my_weld_count));
  
  


